-- Enable Row Level Security
alter table mcqs enable row level security;

-- Create policies to allow access (Read, Insert, Update, Delete)
create policy "Enable access for all users"
on mcqs for all
using (true)
with check (true);





create table if not exists mcqs (
  id uuid default gen_random_uuid() primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  question text not null,
  options jsonb not null,
  explanation text not null,
  subject text not null,
  topic text not null,
  image_url text,
  explanation_image_url text
);




-- =====================================================
-- MASTER SETUP SCRIPT FOR APTIVO
-- Run this entire script in your new Supabase Project's SQL Editor.
-- This handles everything: Tables, Security, and Super Admin Setup.
-- =====================================================

-- 1. CLEANUP (For fresh starts)
DROP FUNCTION IF EXISTS handle_new_user CASCADE;
DROP TABLE IF EXISTS mistake_log CASCADE;
DROP TABLE IF EXISTS attempts CASCADE;
DROP TABLE IF EXISTS assignments CASCADE;
DROP TABLE IF EXISTS set_questions CASCADE;
DROP TABLE IF EXISTS apply_sets CASCADE;
DROP TABLE IF EXISTS questions CASCADE;
DROP TABLE IF EXISTS profiles CASCADE;
DROP TABLE IF EXISTS institutes CASCADE;
DROP TYPE IF EXISTS user_role CASCADE;
DROP TYPE IF EXISTS content_status CASCADE;
DROP TYPE IF EXISTS question_format CASCADE;
DROP TYPE IF EXISTS difficulty_level CASCADE;
DROP TYPE IF EXISTS mistake_type CASCADE;

-- 2. ENABLE EXTENSIONS
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 3. CREATE ENUMS
CREATE TYPE user_role AS ENUM ('SUPER_ADMIN', 'ADMIN', 'STUDENT');
CREATE TYPE content_status AS ENUM ('DRAFT', 'PUBLISHED');
CREATE TYPE question_format AS ENUM ('MCQ', 'SHORT_ANSWER');
CREATE TYPE difficulty_level AS ENUM ('EASY', 'MEDIUM', 'HARD');
CREATE TYPE mistake_type AS ENUM ('CONCEPT', 'CALCULATION', 'SPEED');

-- 4. CREATE TABLES

-- 4.1 INSTITUTES
CREATE TABLE institutes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL UNIQUE,
    domain TEXT UNIQUE,           -- For email matching (e.g. 'harvard.edu')
    official_email TEXT,          -- Contact email
    status TEXT DEFAULT 'PENDING',-- PENDING, APPROVED, REJECTED
    admin_id UUID,               -- Link to the ADMIN user
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 4.2 PROFILES
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    role user_role NOT NULL DEFAULT 'STUDENT',
    institute_id UUID REFERENCES institutes(id) ON DELETE SET NULL,
    full_name TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    -- Constraint: Students don't need an institute immediately, but Admins do.
    CONSTRAINT valid_relations CHECK (
        (role = 'SUPER_ADMIN' AND institute_id IS NULL) OR
        (role = 'ADMIN' AND institute_id IS NOT NULL) OR
        (role = 'STUDENT') -- Flexible for students
    )
);

-- 4.3 QUESTIONS
CREATE TABLE questions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    mode TEXT NOT NULL DEFAULT 'APPLY' CHECK (mode = 'APPLY'),
    topic TEXT NOT NULL,
    subtopic TEXT NOT NULL,
    format question_format NOT NULL,
    stem TEXT NOT NULL,
    options JSONB, -- Array of strings for MCQ
    correct_answer TEXT NOT NULL, -- Index for MCQ or text for Short Answer
    hint TEXT CHECK (hint IS NULL OR char_length(hint) <= 150),
    short_rationale TEXT,
    full_solution TEXT,
    difficulty difficulty_level NOT NULL DEFAULT 'MEDIUM',
    tags TEXT[] DEFAULT '{}',
    status content_status NOT NULL DEFAULT 'DRAFT',
    created_by UUID NOT NULL REFERENCES profiles(id),
    university_id TEXT, -- Optional: Tag question to a specific uni context
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 4.4 APPLY SETS (Quizzes/Tests)
CREATE TABLE apply_sets (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title TEXT NOT NULL,
    slug TEXT NOT NULL UNIQUE,
    topic TEXT NOT NULL,
    is_timed BOOLEAN NOT NULL DEFAULT FALSE,
    duration_minutes INTEGER CHECK (duration_minutes IS NULL OR duration_minutes > 0),
    scoring_policy JSONB NOT NULL DEFAULT '{"per_question": 1, "negative_marking": 0}',
    hint_policy JSONB NOT NULL DEFAULT '{"max_hints": 1, "kind": "step_unblock"}',
    status content_status NOT NULL DEFAULT 'DRAFT',
    created_by UUID NOT NULL REFERENCES profiles(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 4.5 SET_QUESTIONS (Join Table)
CREATE TABLE set_questions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    set_id UUID NOT NULL REFERENCES apply_sets(id) ON DELETE CASCADE,
    question_id UUID NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
    order_index INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(set_id, question_id)
);

-- 4.6 ASSIGNMENTS
CREATE TABLE assignments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    set_id UUID NOT NULL REFERENCES apply_sets(id) ON DELETE CASCADE,
    assigned_by UUID NOT NULL REFERENCES profiles(id),
    institute_id UUID REFERENCES institutes(id) ON DELETE CASCADE,
    student_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
    due_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 4.7 ATTEMPTS
CREATE TABLE attempts (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    question_id UUID NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
    set_id UUID REFERENCES apply_sets(id) ON DELETE SET NULL,
    user_answer TEXT NOT NULL,
    is_correct BOOLEAN NOT NULL,
    time_taken_ms INTEGER NOT NULL DEFAULT 0,
    hints_used INTEGER NOT NULL DEFAULT 0,
    submitted_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 4.8 MISTAKE LOG
CREATE TABLE mistake_log (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    attempt_id UUID NOT NULL REFERENCES attempts(id) ON DELETE CASCADE,
    topic TEXT NOT NULL,
    subtopic TEXT NOT NULL,
    mistake_type mistake_type NOT NULL,
    note TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 5. FUNCTION: SOLUTION GATING
-- This prevents students from seeing answers by querying the table directly.
CREATE OR REPLACE FUNCTION get_question_for_student(p_question_id UUID)
RETURNS TABLE (
    id UUID,
    topic TEXT,
    subtopic TEXT,
    format question_format,
    stem TEXT,
    options JSONB,
    hint TEXT,
    difficulty difficulty_level,
    correct_answer TEXT,
    short_rationale TEXT,
    full_solution TEXT,
    has_attempted BOOLEAN
)
LANGUAGE plpgsql STABLE SECURITY DEFINER
AS $$
DECLARE
    v_has_attempt BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM attempts 
        WHERE attempts.user_id = auth.uid() 
        AND attempts.question_id = p_question_id
    ) INTO v_has_attempt;
    
    RETURN QUERY
    SELECT 
        q.id,
        q.topic,
        q.subtopic,
        q.format,
        q.stem,
        q.options,
        q.hint,
        q.difficulty,
        CASE WHEN v_has_attempt THEN q.correct_answer ELSE NULL END,
        CASE WHEN v_has_attempt THEN q.short_rationale ELSE NULL END,
        CASE WHEN v_has_attempt THEN q.full_solution ELSE NULL END,
        v_has_attempt
    FROM questions q
    WHERE q.id = p_question_id
    AND q.status = 'PUBLISHED';
END;
$$;

-- 6. ENABLE RLS
ALTER TABLE institutes ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE apply_sets ENABLE ROW LEVEL SECURITY;
ALTER TABLE set_questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE attempts ENABLE ROW LEVEL SECURITY;
ALTER TABLE mistake_log ENABLE ROW LEVEL SECURITY;

-- 7. RECURSION-FREE RLS POLICIES
-- We use auth.jwt() -> 'user_metadata' to check roles, avoiding table lookups.

-- Profiles
CREATE POLICY "Public profiles are viewable by everyone" ON profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile" ON profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile" ON profiles FOR UPDATE USING (auth.uid() = id);

-- Institutes
CREATE POLICY "Institutes viewable by everyone" ON institutes FOR SELECT USING (true);
CREATE POLICY "Super Admins manage institutes" ON institutes FOR ALL 
    USING ((auth.jwt() -> 'user_metadata' ->> 'role') = 'SUPER_ADMIN');

-- Questions
CREATE POLICY "Questions viewable if published" ON questions FOR SELECT USING (status = 'PUBLISHED');
CREATE POLICY "Super Admins manage questions" ON questions FOR ALL 
    USING ((auth.jwt() -> 'user_metadata' ->> 'role') = 'SUPER_ADMIN');

-- Apply Sets
CREATE POLICY "Sets viewable if published" ON apply_sets FOR SELECT USING (status = 'PUBLISHED');
CREATE POLICY "Super Admins manage sets" ON apply_sets FOR ALL 
    USING ((auth.jwt() -> 'user_metadata' ->> 'role') = 'SUPER_ADMIN');

-- Set Questions
CREATE POLICY "Set contents viewable by everyone" ON set_questions FOR SELECT USING (true);
CREATE POLICY "Super Admins manage set contents" ON set_questions FOR ALL 
    USING ((auth.jwt() -> 'user_metadata' ->> 'role') = 'SUPER_ADMIN');

-- Assignments
CREATE POLICY "View own assignments" ON assignments FOR SELECT 
    USING (student_id = auth.uid() OR institute_id = (auth.jwt() -> 'user_metadata' ->> 'institute_id')::UUID);
CREATE POLICY "Admins manage assignments" ON assignments FOR ALL 
    USING ((auth.jwt() -> 'user_metadata' ->> 'role') = 'ADMIN');

-- Attempts
CREATE POLICY "View own attempts" ON attempts FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "Create own attempts" ON attempts FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "Admins view institute attempts" ON attempts FOR SELECT 
    USING ((auth.jwt() -> 'user_metadata' ->> 'role') = 'ADMIN');

-- Mistake Log
CREATE POLICY "Manage own mistakes" ON mistake_log FOR ALL 
    USING (EXISTS (SELECT 1 FROM attempts WHERE attempts.id = mistake_log.attempt_id AND attempts.user_id = auth.uid()));

-- 8. AUTOMATION TRIGGERS

-- 8.1 Auto-update timestamps
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

CREATE TRIGGER questions_updated_at BEFORE UPDATE ON questions FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER apply_sets_updated_at BEFORE UPDATE ON apply_sets FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- 8.2 HANDLE NEW USERS & SYNC METADATA
-- This function does two things:
-- 1. Creates the profile entry.
-- 2. Updates the Auth Metadata so RLS can read it instantly without querying the table.
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
    v_role user_role;
    v_institute_id UUID;
BEGIN
    -- Determine role based on email (Hardcoded Super Admin)
    IF NEW.email = 'aptivo.edu@gmail.com' THEN
        v_role := 'SUPER_ADMIN';
    ELSE
        v_role := 'STUDENT';
    END IF;

    -- Create Profile
    INSERT INTO public.profiles (id, full_name, role, institute_id)
    VALUES (
        NEW.id,
        COALESCE(NEW.raw_user_meta_data->>'full_name', 'New User'),
        v_role,
        NULL
    );

    -- Sync Metadata back to Auth (Breaking the RLS recursion loop)
    UPDATE auth.users 
    SET raw_user_meta_data = 
        COALESCE(raw_user_meta_data, '{}'::jsonb) || 
        jsonb_build_object('role', v_role, 'institute_id', NULL)
    WHERE id = NEW.id;

    RETURN NEW;
END;
$$;

CREATE TRIGGER on_auth_user_created 
    AFTER INSERT ON auth.users 
    FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- 9. (Optional) SEED DATA
INSERT INTO institutes (name, domain, status) VALUES 
('Demo University', 'demo.edu', 'APPROVED');
